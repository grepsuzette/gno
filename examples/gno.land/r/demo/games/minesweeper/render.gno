package minesweeper

import (
	"math/rand"
	"std"
	"strconv"
	"strings"
)

// Underwater Minesweeper
// generated by some AI...

const (
	urlCrea = "file:///me/Images/octopus.jpg"
	rRoot   = "/r/grepsuzette/pr2554/v4"
)

var prng *rand.Rand

func Intn(n int) int {
	if prng == nil {
		// Note: our PRNG is not stateful as calling Render is not going
		// to modify this stateless realm. We initialize it here when still nil
		// this creates the randomness we need (seeded from blockchain's height)
		prng = rand.New(rand.NewPCG(uint64(std.GetHeight()), uint64(9)))
	}
	return prng.IntN(n)
}

func Render(path string) string {
	out := "Underwater Minesweeper\n\n"
	out += css()
	board, x, y, debug := parsePath(path)
	var title string
	var lost bool
	if x != -1 && y != -1 {
		lost = !board.Reveal(x, y)
	}
	if lost {
		title = "🤯🤯🤯🤯🤯\n\n"
		title += "Nice try, boomer 🤷\n\n"
		title += "You hit a mine."
	}

	// display the minefield as a matrix of buttons
	out += heading(title)
	for y := range board.cells {
		for x := range board.cells[y] {
			out += button(x, y, board.cells[y][x], lost)
		}
		out += "<br />"
	}
	out += footing()

	// if debug {
	// 	out += ufmt.Sprintf(
	// 		"--- played x=%d y=%d height=%d path=%s error:%s",
	// 		x, y, std.GetHeight(), path, "",
	// 	)
	// }
	return out
}

func button(x, y int, cell Cell, lost bool) string {
	var classes []string
	revealed := cell.IsRevealed || lost
	if revealed {
		classes = append(classes, "d")
	}
	var text string
	switch {
	case cell.IsMine:
		text = "💣"
	case !revealed || cell.AdjacentMines <= 0:
		text = "nbsp;"
	case cell.AdjacentMines > 8:
		panic("should not happen")
	default:
		classes = append(classes, "m"+strconv.Itoa(cell.AdjacentMines))
		text = strconv.Itoa(cell.AdjacentMines)
	}
	return "<button class='" + strings.Join(classes, " ") + "'>" + text + "</button>"
}

func css() string {
	return `<style type="text/css">
    form button {
        background-color: #ccc;
        border-radius: 0px;
        border: 3px outset #eee;
        height: 32px;
        width: 32px;
        margin: 0px; 
        cursor: pointer;
        font-weight: 800;
    }
    form button.d {
        cursor: default;
        border-bottom: 1px solid #888;
        border-left: 1px solid #888;
        border-right: none;
        border-top: none;
    }
    form button:hover {
        background-color: #ddd;
    }
    form button.d:hover {
        background-color: #ccc;
    }
    form button.m1 { color: blue; }
    form button.m2 { color: green; }
    form button.m3 { color: red; }
    form button.m4 { color: navy; }
    div#board { 
		display: flex; 
		flex-direction: row;
	}
	div#board > #left {
		flex-shrink: 1;
        padding-right: 5px;
	}
	div#board > #right {
		flex-shrink: 0;
		flex-basis: auto;
		width: 19em;
	}
    .rotated {
        width: 200px;
        height: 200px;
        background-color: lightblue;
        transform: rotateZ(45deg) rotateX(45deg) rotateY(45deg);
        perspective: 1000px;
    }
</style>
`
}

func heading(speech string) string {
	if speech == "" {
		speech = "<strong>Save me, my underwater realm is threatened by water mines.<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/</strong>"
	}
	return `<form>
` + speech + `
<div id="board">
<div id="left">
<img src="./octopus.jpg" width=128 /><br>
🐠 = 1<br>
🦐 = 2<br>
🦑 = 3<br>
🐙 = 4<br>
🦈 = 5<br>
🐳 = 6<br>

</div>
<div id="right">
`
}

func footing() string {
	return `
</div>
</div>
</form>
`
}

// Decompose path, into valid game and played coordinates (or -1,-1)
// The path is like "state=<hexadecimalBytes>&move=c3"
//
//   - state is empty or 9 characters,
//     imagine the following but without the \n: "-OX\nO--\n---".
//     O always plays first.
//
//   - move coordinate ranges from "a1" to "c3" but can be empty.
//
//   - debug &debug enables printing of a debug line.
func parsePath(path string) (game *Board, x, y int, debug bool) {
	h, e := BreakToMap(path)
	if e != nil {
		panic(e)
	}
	game = BoardFromRepr(h["state"])
	_, debug = h["debug"]
	x, y = -1, -1
	for i, xx := range h["move"] {
		switch i {
		case 0:
			x = int(xx) - int('a')
		case 1:
			y = int(xx) - int('1')
		default:
			panic("invalid move: " + h["move"])
		}
	}
	return game, x, y, debug
}

// Break down a string of url parameters to map[string]string.
// E.g. "foo=a&bar=b" -> (map[string]string{foo:"a", bar:"b"}, nil)
func BreakToMap(querystring string) (map[string]string, error) {
	m := make(map[string]string)
	for _, s := range strings.Split(querystring, "&") {
		if len(strings.TrimSpace(s)) == 0 {
			continue
		}
		idx := strings.Index(s, "=")
		if idx > -1 {
			m[s[:idx]] = s[idx+1:]
		} else {
			m[s] = ""
		}
	}
	return m, nil
}
